# ОПМУ - Лабораторная работа №3

> Вариант 20

* [Цель практикума](#Цель-практикума)
* [Теоретические сведения](#Теоретические-сведения)
* [Задание 1](#Задание-1)

## Цель практикума

Функции, запись бинарных файлов. Работа со структурами и векторами

## Теоретические сведения

ФУНКЦИЯ (передпча параметров через указатель и ссылку, разница и сходство)
 
*Функция* - это именованная последовательность описаний и операторов,
обычно предназначенная для решения определенной задачи. Функция может
принимать параметры и возвращать значение. 

В функциях есть два типа параметров: формальные и фактические.
> *Формальные параметры* (параметры) - это параметры, перечисленные в
заголовке описания функции, их еще называют просто параметрами.
> *Фактические параметры* (аргументы) - это параметры записанные в операторе
вызова функции.

Существует два способа передачи параметров функции:
• по значению;
• по адресу:
	- по указателю;
	- по ссылке.

При передаче параметров *по значению* в память заносятся копии значений
аргументов, и операторы функции работают с этими копиями. Доступа к
исходным значениям параметров у функции нет, а, следовательно, нет
возможности их изменить.
При передаче *по адресу* в память заносятся копии адресов аргументов,
функция осуществляет доступ к ячейкам памяти по этим адресам и может
изменить исходные значения аргументов.

```c++
#include <iostream>

void f(int i, int* j, int& k);

int main()
{
	int i = 1, j = 2, k = 3; std::cout << "i j k\n";
	std::cout << i << ' ' << j << ' ' << k << '\n';
	f(i, &j, k);
	std::cout << i << ' ' << j << ' ' << k;
	return 0;
}

void f(int i, int* j, int& k)
{
	i++;
	(*j)++;
	k++;
}
```

В примере выше параметр i передается по значению. Его изменение
функцией не повлияет на исходное значение. Параметр j передается по адресу с
использованием указателя, при этом для передачи в функцию адреса
фактического параметра используется операция взятия адреса, а для получения
его значения функции требуется операция разыменования.
Параметр k передается по адресу с помощью ссылки. При передаче по
ссылке в функцию передается адрес указанного при вызове параметра, внутри
функции все обращения к параметру неявно разыменовываются. При
использовании ссылок, а не указателей читаемость программы лучше, также это
избавляет от использования операций получения адреса и разыменования.

*Результат*:

```консоль
i j k
1 2 3
1 3 4
```

ВЕКТОР

В Стандартной библиотеке C++ есть и улучшенная версия динамических
массивов (более безопасная и удобная) — std::vector. std::vector идет в комплекте
с дополнительными возможностями, которые делают его одним из самых
полезных и универсальных инструментов в языке C++.

std::vector (или просто «вектор») — это тот же динамический массив, но 
который может сам управлять выделенной себе памятью. Это означает, что 
вы можете создавать массивы, длина которых задается во время выполнения, 
без использования операторов new и delete (явного указания выделения и 
освобождения памяти). std::vector находится в заголовочном файле vector. 
Объявление std::vector следующее:

```c++
#include <vector>
// Нет необходимости указывать длину при инициализации
std::vector<int> array;
std::vector<int> array2 = { 10, 8, 6, 4, 2, 1 }; // используется список инициализаторов для
инициализации массива
std::vector<int> array3{ 10, 8, 6, 4, 2, 1 }; // используется uniform-инициализация для
инициализации массива(начиная с C++11)
```

Обратите внимание, что в неинициализированном, что в
инициализированном случаях вам не нужно явно указывать длину массивов. Это
связано с тем, что std::vector динамически выделяет память для своего
содержимого по запросу.
Доступ к элементам массива может выполняться как через оператор []
(который не выполняет проверку диапазона), так и через функцию at() (которая
выполняет проверку диапазона):

```c++
array[7] = 3; // без проверки диапазона
array.at(8) = 4; // с проверкой диапазона
```

В отличие от стандартных динамических массивов, которые не знают свою
длину, std::vector свою длину запоминает. Чтобы её узнать, нужно использовать
функцию *size()*.

Изменить длину стандартного динамически выделенного массива довольно
проблематично и сложно. Изменить длину std::vector так же просто, как вызвать
функцию *resize()*.

Запись бинарного кода содержится в pdf файле в данной директории

## Задание 1

Для каждого простого сигнала из лабораторной работы No2 написать
функцию, которая будет возвращать объект std::vector с отсчетами сигнала.
Создать std::vector и объединить в нем четыре простых сигнала.
Записать данный вектор в бинарный файл формата. adc
Открыть файл в имитационной среде Спектр-2 и построить осциллограмму.

!ВНИМАНИЕ! Для программы "spectr" нужен бинарный файл с расширением ".adc" с
массивом (вектором) типа float, именно float!

*Source.cpp*

```c++
#include <iostream>
#include <vector>
#include <fstream>
#define M_PI 3.14159265358979323846
using namespace std;

//! Структура заголовка файла АЦП (ADC)
struct ADCFILEHEADER {
	double dt; //!< Период дискретизации в секундах
	unsigned long h; //!< Разрядность АЦП
	unsigned long fN; //!< Общее количество отсчетов в файле
	float Am; //!< Амплитуда, соответствующая максимальному значению целочисленного отсчета
	unsigned long flags; //!< Флаги
	char reserv[8]; //!< Резерв
};
typedef struct ADCFILEHEADER* LPADCFILEHEADER; //!< Указатель на ADCFILEHEADER

#define ADCF_DATA_INTEGER 0x00000000 //!< Тип данных - целочисленные
#define ADCF_DATA_FLOAT 0x00000001 //!< Тип данных - float
#define ADCF_TYPE_REAL 0x00000000 //!< Тип отсчетов - действительные
#define ADCF_TYPE_COMPLEX 0x00000002 //!< Тип отсчетов – комплексные

void inputArrSignal(vector<float>&, float*, int);
bool write_adc(vector<float>, double);

int main()
{
	float data[64]; // массив вычислений
	vector<float> signalPlot; // вектор всех сигналов
	float signalConstant = 10.06;
	double freq_sampling = 48000.0;
	ofstream outFile;

	// CONST
	for (int i = 0; i < 64; i++)
	{
		data[i] = signalConstant;
	}

	// запись в общий массив
	inputArrSignal(signalPlot, data, 0);

	// GIT
	int control = 0;
	for (int i = 0; i < 64; i++)
	{
		if (i == 0)
		{
			data[i] = 0;
			data[++i] = 1;
			control++;
		}
		else
		{
			data[i] = 1;
			control++;

			if (control % 6 == 0)
			{
				control = 0;
				data[++i] = 0;
				data[++i] = 0;
			}
		}
	}

	// запись в общий массив
	inputArrSignal(signalPlot, data, 64);

	// PILA
	control = 0;
	for (int i = 0; i < 64; i++)
	{
		data[i] = (float)1 / 6 * i - control;

		if (i % 6 == 0 && i != 0)
			control++;
	}

	inputArrSignal(signalPlot, data, 128);

	// SIN
	for (int i = 0; i < 64; i++)
	{
		data[i] = sin(float(2 * M_PI * 1600 * i / 48000));
	}

	inputArrSignal(signalPlot, data, 192);

	// Работа с бинарным кодом
	bool l = write_adc(signalPlot, freq_sampling);
	cout << l << endl;

	// Работа с файлами
	outFile.open("file.txt", ios::in);

	for (int i = 0; i < 256; i++)
		outFile << signalPlot[i] << endl;

	outFile.close();

	system("pause");
	return 0;
}

void inputArrSignal(vector<float>& arrSignal, float* arr, int start)
{
	arrSignal.resize(start + 64);

	for (int i = 0; i < 64; i++)
	{
		arrSignal[start] = arr[i];
		start++;
	}
}

bool write_adc(vector<float> data, double freq_sampling)
{
	ADCFILEHEADER head;
	head.Am = 1.0;
	head.h = 32;
	head.dt = 1.0 / freq_sampling;
	head.fN = data.size();
	head.flags = ADCF_DATA_FLOAT;

	const char* FName = "1.adc"; //Путь к файлу
	float im = 0.0;

	/*РАБОТА С БИНАРНЫМ ФАЙЛОМ*/
	ofstream out(FName, ios::binary); //Ставим режим "бинарный файл"
	out.write((char*)&head, sizeof(head)); //Записываем в файл структуру заголовка
	for (int i = 0; i < data.size(); ++i)
	{
		out.write((char*)&data[i], sizeof(data[i])); // Записываем действительные отсчеты из вектора
	}
	out.close();
	return true;
}
```