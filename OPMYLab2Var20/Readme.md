# ОПМУ - Лабораторная работа №2

> Вариант 20

* [Цель практикума](#Цель-практикума)
* [Теоретические сведения](#Теоретические-сведения)
* [Задание 1](#Задание-1)

## Цель практикума

Генерация сложных сигналов

## Теоретические сведения

*Работа с текстовыми файлами в С++*
Для работы с файлами используются специальные типы данных,
называемые потоками. В программах на языке C++ при работе с текстовыми
файлами необходимо подключать библиотеку fstream:

`#include <fstream>`

Поток ifstream служит для работы с файлами в режиме чтения, а ofstream в
режиме записи. Для работы с файлами в режиме, как записи, так и чтения, служит
поток fstream.
Для того чтобы записывать данные в текстовый файл, необходимо:
1. Описать переменную типа ofstream.
2. Открыть файл с помощью функции open.
3. Вывести информацию в файл.
4. Обязательно закрыть файл.
Как было сказано ранее, для того чтобы начать работать с текстовым
файлом, необходимо описать переменную типа ofstream. Например, так:

ofstream outFile;

Будет создана переменная outFile для записи информации в файл. На
следующем этапе файл необходимо открыть для записи. В общем случае оператор
открытия потока будет иметь вид:

outFile.open("file.txt", mode);

Здесь outFile — переменная, описанная как ofstream, file.txt — полное имя
файла на диске, mode — режим работы с открываемым файлом. Стоит обратить
внимание на то, что при указании полного имени файла нужно ставить двойной
слеш. Для обращения, например к файлу “accounts.txt”, находящемуся в папке
sites на диске D, в программе необходимо указать: “D:\\sites\\accounts.txt”.
Функция open() требует в качестве аргумента строки в стиле С. Это может быть
литеральная строка или же строка, сохраненная в символьном массиве.
Файл может быть открыт в одном из следующих режимов:

• ios:: in — открыть файл в режиме чтения данных; режим является
режимом по умолчанию для потоков ifstream;
• ios::out — открыть файл в режиме записи данных (при этом
информация о существующем файле уничтожается); режим является
режимом по умолчанию для потоков ofstream;
• ios::app — открыть файл в режиме записи данных в конец файла;
• ios::ate — передвинуться в конец уже открытого файла;
• ios::trunc — очистить файл, это же происходит в режиме ios::out;
• ios::nocreate — не выполнять операцию открытия файла, если он не
существует;
• ios::noreplace — не открывать существующий файл.

Параметр mode может отсутствовать, в этом случае файл
открывается в режиме по умолчанию для данного потока.
ifstream file;
file.open("Test.txt", ios::in); // открыть файл в режиме для чтения
ifstream file;
file.open("Test.txt"); // открыть файл в режиме для чтения (по умолчанию)
После удачного открытия файла (в любом режиме) в переменной outFile будет
храниться true, в противном случае false. Это позволит проверить корректность
операции открытия файла.

Для считывания данных из текстового файла, необходимо:
1. Описать переменную типа ifstream.
2. Открыть файл с помощью функции open.
3. Считать информацию из файла, при считывании каждой порции
данных необходимо проверять, достигнут ли конец файла.
4. Закрыть файл.

Для того чтобы прочитать информацию из текстового файла, необходимо
описать переменную типа ifstream. После этого нужно открыть файл для чтения с
помощью оператора open. Если переменную назвать fromFile, то первые два
оператора будут такими:

ifstream fromFile;
fromFile.open("D:\\sites\\accounts.txt");

После открытия файла в режиме чтения из него можно считывать
информацию точно так же, как и с клавиатуры, указав имя потока, из которого
будет происходить чтение данных.
Например, для чтения данных из потока fromFile в переменную a, оператор
ввода будет выглядеть так:

fromFile >> a;

Два числа в текстовом редакторе считаются разделенными, если между
ними есть хотя бы один из символов: пробел, табуляция, символ конца строки.
Хорошо, когда программисту заранее известно, сколько и какие значения
хранятся в текстовом файле. Однако часто известен лишь тип значений,
хранящихся в файле, при этом их количество может быть различным. Для
решения данной проблемы необходимо считывать значения из файла поочередно,
а перед каждым считыванием проверять, достигнут ли конец файла с помощью
функции fromFile.eof(). Здесь fromFile — имя потока, eof() - функция,
возвращающая логическое значение (true или false), в зависимости от того
достигнут ли конец файла.
Следовательно, цикл для чтения содержимого всего файла можно записать
так:

//организуем для чтения значений из файла цикл, выполнение //цикла прервется, когда
достигнем конец файла,
//в этом случае fromFile.eof() вернет истину
while(!fromFile.eof())
{
//чтение очередного значения из потока fromFile в переменную a fromFile >> a;
//далее идет обработка значения переменной a
}

Для чтения отдельных символов можно использовать функцию get() и
функцию getline() - для чтения целых строк.

## Задание 1

Составить программу для генерации сложного сигнала, состоящего из четырех частей, каждая длиной 64 отсчета.
Записать в текстовый файл отсчеты сложного сигнала (256 отсчетов).

*Source.cpp*

```c++
#include <iostream>
#include <fstream> // работа с текстовыми файлами с++
#define M_PI 3.14159265358979323846
using namespace std;

void inputArrSignal(double*, double*, int);

int main()
{
	double data[64]; // массив вычислений
	double signalPlot[256]; // массив всех сигналов
	double signalConstant = 10.06;
	ofstream outFile;

	// CONST
	for (int i = 0; i < 64; i++)
	{
		data[i] = signalConstant;
	}

	// запись в общий массив
	inputArrSignal(signalPlot, data, 0);

	// GIT
	int control = 0;
	for (int i = 0; i < 64; i++)
	{
		if (i == 0)
		{
			data[i] = 0;
			data[++i] = 1;
			control++;
		}
		else
		{
			data[i] = 1;
			control++;

			if (control % 6 == 0)
			{
				control = 0;
				data[++i] = 0;
				data[++i] = 0;
			}
		}
	}

	// запись в общий массив
	inputArrSignal(signalPlot, data, 64);

	// PILA
	control = 0;
	for (int i = 0; i < 64; i++)
	{
		data[i] = (double)1 / 6 * i - control;

		if (i % 6 == 0 && i != 0)
			control++;
	}

	inputArrSignal(signalPlot, data, 128);

	// SIN
	for (int i = 0; i < 64; i++)
	{
		data[i] = sin(double (2 * M_PI * 1600 * i / 48000));
	}

	inputArrSignal(signalPlot, data, 192);


	// Работа с файлами
	outFile.open("file.txt", ios::in);

	for (int i = 0; i < 256; i++)
		outFile << signalPlot[i] << endl;

	outFile.close();

	system("pause");
	return 0;
}

void inputArrSignal(double* arrSignal, double* arr, int start)
{
	for (int i = 0; i < 64; i++)
	{
		arrSignal[start] = arr[i];
		start++;
	}
}
```