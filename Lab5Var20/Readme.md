# ИТиП - Лабораторная работа №5

> Вариант 20 (Вариант 6)

* [Цель практикума](#Цель-практикума)
* [Краткие сведения](#Краткие-сведения)
* [Задание](#Задание)

## Цель практикума

Понятие класса. Члены класса. Друзья класса. Перегрузка операторов

## Краткие сведения

*Ссылки*

В языке C++ также появились типы-ссылки: lvalue и rvalue. Ссылки подобны указателям, однако они не могут работать с динамической памятью и не могут 
быть изменены после инициализации. Можно считать, что ссылки – это псевдонимы. Ссылки lvalue ссылаются на объекты, а rvalue обычно на временные объекты. 
Ссылки можно использовать при передаче параметров функции. В таком случае функция сможет изменить значения передаваемых переменных. Ниже представлен 
пример определения и использования ссылок.

```c++
int &a = x; //lvalue ссылка
int &&b = x + 5; //rvalue ссылка
```

Однако в таком случае, передать временные объекты в функцию не получится. Для того чтобы это исправить, необходимо сообщить компилятору, что мы не будем 
изменять передаваемые параметры с использованием ключевого слова const либо передавать параметры с использованием rvalue-ссылок

```c++
// Передача	параметров	по	ссылке	на константный объект
void f(const int &a, const int &b) { }

Передача параметров по rvalue-ссылке
void f(int &&a, int &&b) { }
```

*Перегрузка функций*

В языке C++ в отличие от C разрешено давать функциям одинаковые имена, если они имеют разные типы аргументов. Такое определение функций называется перегрузкой функций.

*Аргументы функции по умолчанию*

Язык C++ поддерживает аргументы функции по умолчанию. Суть в том, что при объявлении функции параметрам указываются значения аргументов по умолчанию. 
В случае, если при вызове функции аргумент не был передан, ему присваивается значение по умолчанию. Аргументы по умолчанию должны быть последними в списке аргументов.

```c++
void f(double x, double y = 0, double z = 1)
{
	
}

void example()
{
	f(1, 2, 3);
	//x = 1, y = 2, z = 3
	f(1, 2); \
	//x = 1, y = 2, z = 1 f(5);
	//x = 5, y = 0, z = 1
}
```

*Определение классов: данные-члены, функции-члены, уровень доступа к членам*

Язык С++ является объектно-ориентированным языком программирования. В C++ используется класс-ориентированный подход к созданию программ. Определение простого класса
напоминает определение структуры в языке C. В отличие от структур в языке C структуры и классы в языке C++ могут иметь не только данные, но и функции. Данные, 
определённые внутри структур и классов, называются данными- членами. Функции, определённые внутри структур и классов, называются функциями-членами. Классы и структуры
в языке С++ отличаются друг от друга уровнем доступа к членам по умолчанию. Члены класса по умолчанию доступны только функциям-членам этого класса и не доступны другим
функциям. Члены структур по умолчанию доступны любым функциям. При определении структур и классов можно явно указать, какие члены будут видны извне, а какие только 
внутри. Для этого используются секции `public`, `protected`, `private`.

*Объявление константных функций*

```c++
class A
{
	public:
		int GetX() const { return x; } 
		int GetY() const { return y; } 
		int GetZ() const { return z; } 
		
		void Set(int x, int y)
		{
			this.x = x; 
			this.y = y;
			z = x + y;
		}
	private:
		int x; 
		int y; 
		double z;
};
```
Функции-члены можно определять вне класса. В этом случае в определении класса указывается прототип, а вне определения класса определяется функция. К имени функции 
добавляется префикс класса. Префикс отделяется двойным двоеточием (::)

*Определение функций членов вне класса*

```c++
class A
{
	public:
		int GetX() const { return x; } 
		int GetY() const { return y; } 
		int GetZ() const { return y; }

		void Set(int x, int y);

	private:
		int x;
		int y;
		double z;
};

void A::Set(int x, int y)
{
	this.x = x; this.y = y; z = x + y;
}
```
Обычно класс определяется в заголовочном файле, а реализация его методов в cpp файле.

*Статические члены класса*

Каждый объект класса имеет собственную копию данных-членов класса. Иногда требуется, чтобы все экземпляры класса имели одну копию данных. C++ позволяет определять 
такие данные с помощью ключевого слова static. Обращение к таким данным может осуществляться как через экземпляр объекта (как к обычным данным-членам), так и через
имя класса. Статические функции-члены отличаются от нестатических тем, что они не имеют неявного аргумента this, поэтому не могут обращаться к нестатическим 
функциям-членам. Нестатические функции-члены могут обращаться к статическим членам класса.

*Определение статических данных-членов и функций членов*

```c++
class B
{
	static int x; public:
	static int GetX() { return x; } 
	static void SetX(int x) 
	{ 
		B::x = x; 
	}
};
```

*Использование статических функций-членов*

```c++
void example()
{
	B::SetX(1); // B::x равно 1 B b;
	b.SetX(5); // B::x равно 5
	int a = B::GetX(); // a равно 5
}
```

*Конструкторы*

При создании объекта вызывается специальная функция-конструктор. Если мы не предоставляем её реализацию, она генерируется автоматически.
Существуют 5 видов конструкторов:
	* Конструктор по умолчанию – конструктор, не требующий аргументов
	* Конструктор преобразования – конструктор, получающий единственный аргумент
	* Конструктор инициализации – конструктор, получающий несколько аргументов
	* Конструктор копирования – конструктор, получающий lvalue ссылку на другой экземпляр класса того же типа
	* Конструктор перемещения – конструктор, получающий rvalue ссылку на другой экземпляр класса того же типа
При определении конструктора тип возвращаемого значения не указывается, имя совпадает с именем класса. Пример определения конструктора по 
умолчанию, конструктора преобразования, конструктора инициализации:

*Определение конструктора по умолчанию*
```c++
class A
{
	public:
		A()
		{
			x = y = 0; z = 0.0;
		}
		//Ранее определённые функции
		//опущены
	
	private:
		int x;
		int y;
		double z;
};
```

*Определение конструктора преобразования*

```c++
class A
{
	public:
		A(int a)
		{
			x = a; y = a; z = a;
		}
		//Ранее определённые
		//функции опущены

	private:
		int x;
		int y;
		double z;
};
```

*Определение конструктора инициализации*

```c++
class A
{
	public:
		A(int a, int b, double c)
		{
			x = a; y = b; z = c;
		}
		//Ранее определённые
		//функции опущены

	private:
		int x;
		int y;
		double z;
};
```

*Пример	определения	конструктора с аргументами по умолчанию*
```c++
class A
{
	public:
		A(int a = 0, int b = 0, double c = 0)
			: x(a), y(b), z(c)
		{ }
	//Ранее определённые
	//функции опущены

	private:
		int x;
		int y;
		double z;
};
```

*Примеры вызова конструкторов*
```c++
A a1; // конструктор по умолчанию
A a2 = 1; // конструктор преобразования
A a3(1, 2, 3.0); // конструктор инициализации
A a4 = a1; // конструктор копирования
```

*Деструктор*

При	уничтожении	объекта	вызывается	специальная	функция-деструктор.	Пример объявления деструктора:

```c++
class A
{
	public:
		~A()
		{ }
	//Ранее определённые
	//функции опущены

	private:
		int x;
		int y;
		double z;
};
```

> ! В перегрузках вывод и ввода нужно использовать ostream и istream:
```c++
// "Вывести" нужно испольозвать ostream
ostream& operator << (ostream& stream, Complex c)
{
    stream << c.Re << " + i( " << c.Im << " )" << endl;
    return stream;
}

// "Ввести" нужно использовать istream
istream& operator >> (istream& stream, Complex c)
{
    cout << "Введите действительную часть: ";
    stream >> c.Re;
    cout << "Введите мнимую часть: ";
    stream >> c.Im;
    return stream;
}
```

## Задание

Выберите для выполнения лабораторной работы свой вариант. Для выбранного варианта определите класс, включив в него:
	* конструктор по умолчанию;
	* конструктор инициализации;
	* конструктор преобразования базового типа к типу, определяемому разрабатываемым классом;
В разрабатываемом классе перегрузите потоковые операции для объектов класса. Для выполнения задания предложенного варианта перегрузите
необходимые математические операции. При разработке класса вашего варианта учтите индивидуальные уточнения для функций – членов класса.
Разработайте для объектов вашего класса предложенные в каждом варианте пользовательские функции.
Разработайте функцию main, организующую ввод данных и демонстрацию работы разработанных функций


*Header.h*

```c++
#pragma once
#include <iostream>
using namespace std;

class Complex {
public:

    // Конструкторы
    Complex() : Re(0), Im(0) {}                        // конструктор по-умолчанию
    Complex(double re) : Re(re), Im(0) {}              // конструктор преобразования
    Complex(double re, double im) : Re(re), Im(im) {}  // конструктор инициализации

    // Перегрузка операции вывода (дружественная)
    friend ostream& operator << (ostream&, Complex);

    // Публичные функции-члены (дружественные) по заданию
    friend double Re(Complex); // Действительная часть
    friend double Im(Complex); // Мнимая часть
    friend double R(Complex);  // Молуль комплексного числа
    friend double Phi(Complex); // Аргумент комплексного числа

    // Перегрузка математических операций для комплексных чисел
    friend Complex operator+(Complex, Complex); // Операция суммы
    friend Complex operator-(Complex, Complex); // Операция разности
    friend Complex operator*(Complex, Complex); // Операция произведения
    friend Complex operator/(Complex, Complex); // Операция частного

    // Функция выполнения индивидуального задания
    friend Complex y(Complex);
    friend double sin(Complex);
    friend double cos(Complex);
    friend double exp(Complex);

private:
    double Re, Im;
};
```

*Source.cpp*

```c++
#include <iostream>
#include "Header.h";
#include <complex> // Для проверки созданых функций
using namespace std;

int main() {

    setlocale(LC_ALL, "Russian");

    double re, im;

    // Проверка работоспособности конструкторов
    Complex l;
    cout << l << endl;

    Complex s(7.0);
    cout << s << endl;

    Complex z(1, 2);
    cout << z << endl;

    cout << "Введите комплексные числа\n";
    cout << "Введите действитульную часть 1 числа: ";
    cin >> re;
    cout << "Введите мнимую часть 1 числа: ";
    cin >> im;

    cout << endl;

    Complex Z1(re, im);

    cout << Z1 << endl;
    complex<double> z1(re, im);

    cout << "Введите действитульную часть 2 числа: ";
    cin >> re;
    cout << "Введите мнимую часть 2 числа: ";
    cin >> im;

    cout << endl;

    Complex Z2(re, im);

    cout << Z2 << endl;
    complex<double> z2(re, im);

    // Вывод действительной части комплексного числа
    cout << "Действительная часть: " << Re(Z1) << endl;
    cout << "Проверка: " << z1.real() << endl;

    cout << endl;

    // Вывод мнимой части комплексного числа
    cout << "Мнимая часть: " << Im(Z1) << endl;
    cout << "Проверка: " << z1.imag() << endl;

    cout << endl;

    // Вывод модуля комплексного числа
    cout << "Модуль комплексного числа: " << R(Z1) << endl;
    cout << "Проверка: " << abs(z1) << endl;

    cout << endl;

    // Вывод аргумента комплексного числа
    cout << "Аргумент комплексного числа: " << Phi(Z1) << endl;
    cout << "Проверка: " << arg(z1) << endl;

    cout << endl;

    // Перегрузка операции сложения
    cout << "Сумма комплексных чисел: " << Z1 + Z2;
    cout << "Проверка: " << z1 + z2 << endl;

    cout << endl;

    // Перегрузка операции разности
    cout << "Разность комплексных чисел: " << Z1 - Z2;
    cout << "Проверка: " << z1 - z2 << endl;

    cout << endl;

    // Перегрузка операции произведения
    cout << "Произведение комплексных чисел: " << Z1 * Z2;
    cout << "Проверка: " << z1 * z2 << endl;

    cout << endl;

    // Перегрузка операции частного
    cout << "Частное комплексных чисел: " << Z1 / Z2;
    cout << "Проверка: " << z1 / z2 << endl;

    cout << endl;

    // Расчёт индивидуального задания
    cout << "Результат индивидуального задания: " << y(Z1);
}
```

*OperFunc.cpp*

```c++
#define _USE_MATH_DEFINES
#include <iostream>
#include <cmath>
#include "Header.h";
using namespace std;

// "Вывести" нужно испольозвать ostream
ostream& operator << (ostream& stream, Complex c)
{
    stream << c.Re << " + i( " << c.Im << " )" << endl;
    return stream;
}

double Re(Complex c)
{
    return c.Re;
}

double Im(Complex c)
{
    return c.Im;
}

double R(Complex c)
{
    return sqrt(pow(c.Re, 2) + pow(c.Im, 2));
}

double Phi(Complex c)
{
    if (c.Re > 0 && c.Im > 0)
        return atan(c.Im / c.Re);
    else if (c.Re > 0 && c.Im < 0)
        return atan(c.Im / c.Re);
    else if (c.Re < 0 && c.Im < 0)
        return -M_PI + atan(c.Im / c.Re);

    return M_PI + atan(c.Im / c.Re);
}

Complex operator+(Complex x, Complex y)
{
    Complex result;
    result.Re = x.Re + y.Re;
    result.Im = x.Im + y.Im;
    return result;
}

Complex operator-(Complex x, Complex y)
{
    Complex result;
    result.Re = x.Re - y.Re;
    result.Im = x.Im - y.Im;
    return result;
}

Complex operator*(Complex x, Complex y)
{
    Complex result;
    result.Re = x.Re * y.Re - x.Im * y.Im;
    result.Im = x.Re * y.Im + y.Re * x.Im;
    return result;
}

Complex operator/(Complex x, Complex y)
{
    Complex result;
    result.Re = (x.Re * y.Re + x.Im * y.Im) / (pow(y.Re, 2) + pow(y.Im, 2));
    result.Im = (x.Im * y.Re - x.Re * y.Im) / (pow(y.Re, 2) + pow(y.Im, 2));
    return result;
}

Complex y(Complex z)
{
    Complex s = z;
    s.Re = 2 + 3 * sin(z) * exp(z);
    s.Im = 3 * exp(z) * cos(z);
    return s;
}

double sin(Complex z)
{
    return sin(z.Im);
}

double cos(Complex z)
{
    return cos(z.Im);
}

double exp(Complex z)
{
    return 1 / exp(z.Re);
}
```